<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Admin Intake Viewer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css" />
  <style>
    .admin-wrap{max-width:960px;margin:6vh auto;padding:1rem}
    .admin-head{display:flex;gap:.8rem;align-items:center;margin-bottom:1rem}
    .admin-input{padding:.6rem .8rem;border:1px solid var(--card-border);border-radius:10px;width:320px}
    .admin-btn{padding:.6rem 1rem;border:none;border-radius:10px;background:linear-gradient(90deg,#7f5af0,#2cb67d);color:#fff;font-weight:700;cursor:pointer}
    table{width:100%;border-collapse:collapse;background:#fff;border:1px solid var(--card-border);border-radius:12px;overflow:hidden}
    th,td{padding:.6rem .8rem;border-bottom:1px solid #eee;font-size:.95rem}
    th{background:#fafbff;text-align:left}
    .muted{opacity:.7;font-size:.86rem}
  </style>
</head>
<body>
  <div class="admin-wrap">
    <h2 class="hero-title" style="margin:0 0 .6rem">Admin Intake Viewer</h2>
    <p class="muted">Recent intake activity and profiles</p>
    <div class="card" style="margin:.8rem 0;padding:0.6rem 0.8rem">
      <div style="display:flex;gap:.6rem;align-items:center;flex-wrap:wrap">
        <strong>Profiles</strong>
        <button id="reload-profiles" class="admin-btn" style="padding:.3rem .6rem">Refresh</button>
        <span class="muted" id="profiles-count" aria-live="polite"></span>
      </div>
      <div id="profiles" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:.6rem;margin-top:.6rem"></div>
    </div>
    <div class="admin-head" style="gap:1rem;">
      <label class="muted" for="limit">Show</label>
      <select id="limit" class="admin-input" style="width:auto">
        <option value="10">10</option>
        <option value="25" selected>25</option>
        <option value="50">50</option>
        <option value="100">100</option>
      </select>
      <button id="load" class="admin-btn">Refresh</button>
    </div>
    <div id="out" class="card" style="padding:0">
      <table aria-label="Intake entries">
        <thead>
          <tr><th>When</th><th>Name</th><th>Type</th><th>Age</th><th>School/Company</th><th>Device</th><th>IP</th><th>Actions</th></tr>
        </thead>
        <tbody id="rows"><tr><td class="muted" colspan="8">No data loaded</td></tr></tbody>
      </table>
    </div>
  </div>
  <script>
  async function fetchProfiles(limit) {
    const paths = [
      '/api/profiles/list',
      '/.netlify/functions/profiles/list',
      '/.netlify/functions/profiles'
    ];
    let lastError = null, lastStatus = 0;
    for (const p of paths) {
      try {
        const u = new URL(p, location.origin);
        if (limit) u.searchParams.set('limit', String(limit));
        const r = await fetch(u.toString());
        if (r.ok) return await r.json();
        lastStatus = r.status;
      } catch (e) { lastError = e; }
    }
    const errMsg = lastStatus ? `HTTP ${lastStatus}` : (lastError?.message || 'Network error');
    throw new Error(errMsg);
  }
  function renderProfiles(list) {
    const grid = document.getElementById('profiles');
    const countEl = document.getElementById('profiles-count');
    if (!grid) return;
    if (!Array.isArray(list) || list.length === 0) {
      grid.innerHTML = '<div class="muted">No profiles yet</div>';
      if (countEl) countEl.textContent = '';
      return;
    }
    grid.innerHTML = '';
    list.forEach(p => {
      const card = document.createElement('button');
      card.className = 'panel-tile';
      card.style.textAlign = 'left';
      card.style.padding = '.6rem .7rem';
      card.setAttribute('data-key', p.key);
      card.innerHTML = `<div style="font-weight:700">${(p.first||'')+' '+(p.last||'')}</div>
        <div class="muted" style="font-size:.85rem">Last seen: ${p.lastSeen ? fmt(p.lastSeen) : '—'}</div>
        <div class="muted" style="font-size:.85rem">Logins: ${p.loginCount||0} · Entries: ${p.entriesCount||0}</div>
        <div class="muted" style="font-size:.85rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">Devices: ${(p.devices||[]).join(', ')}</div>`;
      card.addEventListener('click', () => filterByProfile(p));
      grid.appendChild(card);
    });
    if (countEl) countEl.textContent = `${list.length} profile(s)`;
  }
  async function loadProfiles() {
    try {
      const j = await fetchProfiles(100);
      renderProfiles(j.profiles || []);
    } catch (e) {
      const grid = document.getElementById('profiles');
      if (grid) grid.innerHTML = `<div class="muted">Failed to load profiles: ${e.message||''}</div>`;
    }
  }
  function filterByProfile(p) {
    // Simple filter: reload entries and keep those matching name
    load().then(() => {
      try {
        const name = ((p.first||'')+' '+(p.last||'')).trim().toLowerCase();
        const trs = Array.from(rows.querySelectorAll('tr'));
        let shown = 0;
        trs.forEach(tr => {
          const tds = tr.querySelectorAll('td');
          if (!tds || tds.length < 2) return;
          const rowName = (tds[1].textContent || '').trim().toLowerCase();
          const keep = rowName === name;
          tr.style.display = keep ? '' : 'none';
          if (keep) shown++;
        });
        if (shown === 0) {
          rows.insertAdjacentHTML('afterbegin', '<tr><td class="muted" colspan="8">No entries for this profile yet</td></tr>');
        }
      } catch {}
    });
  }
  const fmt = (ts)=> new Date(ts).toLocaleString();
  const rows = document.getElementById('rows');
  function parseUA(ua=''){
    try {
      const parts = [];
      if (/Windows/i.test(ua)) parts.push('Windows');
      else if (/(Macintosh|Mac OS X)/i.test(ua)) parts.push('macOS');
      else if (/iPhone|iPad|iOS/i.test(ua)) parts.push('iOS');
      else if (/Android/i.test(ua)) parts.push('Android');
      else if (/Linux/i.test(ua)) parts.push('Linux');
      if (/Edg\//i.test(ua)) parts.push('Edge');
      else if (/OPR\//i.test(ua)) parts.push('Opera');
      else if (/Chrome\//i.test(ua) && !/Chromium/i.test(ua)) parts.push('Chrome');
      else if (/Firefox\//i.test(ua)) parts.push('Firefox');
      else if (/Safari\//i.test(ua) && !/Chrome\//i.test(ua)) parts.push('Safari');
      return parts.join(' · ');
    } catch { return ''; }
  }
  async function fetchEntries(limit){
    const paths = [
      '/api/intake/entries',
      '/.netlify/functions/intake/entries',
      '/.netlify/functions/intake?entries=1'
    ];
    let lastError = null, lastStatus = 0;
    for (const p of paths){
      try {
        const u = new URL(p, location.origin);
        if (limit) u.searchParams.set('limit', String(limit));
        const r = await fetch(u.toString());
        if (r.ok) return await r.json();
        lastStatus = r.status;
      } catch (e) { lastError = e; }
    }
    const errMsg = lastStatus ? `HTTP ${lastStatus}` : (lastError?.message || 'Network error');
    throw new Error(errMsg);
  }
  async function load() {
      const limitSel = document.getElementById('limit');
      const limit = parseInt(limitSel?.value || '25', 10) || 25;
      rows.innerHTML = '<tr><td class="muted" colspan="8">Loading…</td></tr>';
      try {
        const j = await fetchEntries(limit);
        const list = Array.isArray(j.entries) ? j.entries : [];
        if (!list.length) { rows.innerHTML = '<tr><td class="muted" colspan="8">No entries yet</td></tr>'; return; }
        rows.innerHTML = '';
        list.forEach(e => {
          const tr = document.createElement('tr');
          const userType = e.type || e.userType || '';
          const schoolOrCompany = userType === 'student' ? (e.school || e.schoolName || '') : (e.company || e.companyName || '');
          tr.innerHTML = `<td>${fmt(e.ts||Date.now())}</td><td>${(e.first||'')+' '+(e.last||'')}</td><td>${userType}</td><td>${e.age||''}</td><td>${schoolOrCompany}</td><td class="muted">${parseUA(e.ua||'')}</td><td class="muted">${e.ip||''}</td><td><button data-ts="${e.ts}" class="admin-btn" style="padding:.3rem .6rem">Delete</button></td>`;
          rows.appendChild(tr);
        });
      } catch (e) {
        rows.innerHTML = `<tr><td class="muted" colspan="8">Failed to load: ${e.message || ''}</td></tr>`;
      }
    }
  document.getElementById('load').addEventListener('click', load);
  // Auto-load on mount
  load();
  loadProfiles();
  document.getElementById('reload-profiles').addEventListener('click', loadProfiles);
    rows.addEventListener('click', async (e) => {
      const btn = e.target.closest('button[data-ts]');
      if (!btn) return;
      const ts = btn.getAttribute('data-ts');
      if (!confirm('Delete this entry?')) return;
  const u = new URL('/api/intake', location.origin);
      u.searchParams.set('ts', ts);
  // Public list; but delete still requires admin key — prompt inline
  const key = prompt('Enter admin key to delete:');
  if (!key) return;
  u.searchParams.set('key', key);
  u.searchParams.set('k', key.replace(/[^a-z0-9]/gi, '').toLowerCase());
  const r = await fetch(u.toString(), { method: 'DELETE', headers: { 'x-admin-key': key } });
      if (r.ok) load();
    });
  </script>
</body>
</html>
